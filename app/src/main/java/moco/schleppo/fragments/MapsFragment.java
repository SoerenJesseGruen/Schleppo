package moco.schleppo.fragments;import android.Manifest;import android.app.Dialog;import android.app.Fragment;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences;import android.content.pm.PackageManager;import android.graphics.Bitmap;import android.graphics.Color;import android.location.Location;import android.location.LocationListener;import android.location.LocationManager;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.annotation.RequiresApi;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.view.Window;import android.widget.Button;import android.widget.Toast;import com.google.android.gms.common.ConnectionResult;import com.google.android.gms.common.api.GoogleApiClient;import com.google.android.gms.location.LocationRequest;import com.google.android.gms.location.LocationServices;import com.google.android.gms.maps.CameraUpdateFactory;import com.google.android.gms.maps.GoogleMap;import com.google.android.gms.maps.MapFragment;import com.google.android.gms.maps.OnMapReadyCallback;import com.google.android.gms.maps.model.BitmapDescriptorFactory;import com.google.android.gms.maps.model.Circle;import com.google.android.gms.maps.model.CircleOptions;import com.google.android.gms.maps.model.LatLng;import com.google.android.gms.maps.model.Marker;import com.google.android.gms.maps.model.MarkerOptions;import moco.schleppo.R;import static android.os.Build.VERSION_CODES.M;/** * Created by golive on 29.11.16. */public class MapsFragment extends Fragment implements OnMapReadyCallback,        GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener,        View.OnClickListener, com.google.android.gms.location.LocationListener {    private GoogleMap mMap;    private LocationManager locationManager;    private LocationListener locationListener;    private GoogleApiClient mGoogleApiClient;    private Location mLastLocation, markerLocation;    private Marker mCurrLocationMarker, markerLocationMarker;    private LocationRequest mLocationRequest, forceUpdateRequester;    // Daten Speicher.    private String file = "locationData";    private Button bWarning, bMarker, bNavigation;    boolean zoomAnimationRunning = false;    long zoomAnimationDelay = 3000L;    SharedPreferences sharedPreferences;    public void init() {        locationManager = (LocationManager) getActivity().getSystemService(Context.LOCATION_SERVICE);        forceUpdateRequester = LocationRequest.create();        forceUpdateRequester.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);        //Location daten speichern                sharedPreferences = getActivity().getPreferences(Context.MODE_PRIVATE);        locationListener = new LocationListener() {            @Override            public void onLocationChanged(Location location) {                mLastLocation = location;                if (mCurrLocationMarker != null) {                    mCurrLocationMarker.remove();                }                //Place current location marker                LatLng latLng = new LatLng(location.getLatitude(), location.getLongitude());                if (markerLocationMarker != null)                    markerLocationMarker.remove();                MarkerOptions markerOptions = new MarkerOptions();                markerOptions.position(latLng);                markerOptions.title("Aktuelle Position");                Bitmap.Config config = Bitmap.Config.ARGB_8888;                //invisible marker                markerOptions.icon(BitmapDescriptorFactory.fromBitmap(Bitmap.createBitmap(1, 1, config)));                mCurrLocationMarker = mMap.addMarker(markerOptions);                if (markerLocation != null) {                    MarkerOptions mMarkerOption = new MarkerOptions();                    mMarkerOption.position(new LatLng(markerLocation.getLatitude(), markerLocation.getLongitude()));                    mMarkerOption.title("Hier gepackt!!");                    mMarkerOption.icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_GREEN));                    markerLocationMarker = mMap.addMarker(mMarkerOption);                }                //move map camera               if (markerOptions != null)                    mMap.moveCamera(CameraUpdateFactory.newLatLng(latLng));                    mMap.animateCamera(CameraUpdateFactory.zoomTo(17));                //stop location updates                if (mGoogleApiClient != null) {                    stopLocationUpdates();                }                //für alle warnungen einer Liste (for-each schleifenbody)                CircleOptions warnung = new CircleOptions();                warnung.center(latLng);                warnung.clickable(true);                warnung.radius(1000);                warnung.strokeColor(Color.WHITE);                warnung.fillColor(Color.parseColor("#32FF0000")); //20% transparentes rot                warnung.strokeWidth(2);                Circle cWarnungskreis = mMap.addCircle(warnung);  //MUSS gesichert werden zum löschen des kreises                cWarnungskreis.remove();            }            @Override            public void onStatusChanged(String s, int i, Bundle bundle) {            }            @Override            public void onProviderEnabled(String s) {            }            @Override            public void onProviderDisabled(String s) {            }        };        if (checkLocationPermission())            locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, locationListener);    }    /**     * Hilfsmethode des LocationListeners     */    private void stopLocationUpdates() {        LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, this);    }    /**     * Hilfsmethode zum animierten zoomen     */    private void animatedZooming(Location marker) {        if (marker == null)            return; //ohne marker kein zoomen möglich        LatLng lng = new LatLng(marker.getLatitude(), marker.getLongitude());        mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(lng, 17));        mMap.animateCamera(CameraUpdateFactory.zoomIn());        mMap.animateCamera(CameraUpdateFactory.zoomTo(17), (int) zoomAnimationDelay, null);        zoomAnimationRunning = true;        bWarning.postDelayed(new Runnable() {            @Override            public void run() {                zoomAnimationRunning = false;            }        }, zoomAnimationDelay);    }    @Nullable    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {        View rootView = inflater.inflate(R.layout.fragment_maps, container, false);        bWarning = (Button) rootView.findViewById(R.id.bWarning);        bMarker = (Button) rootView.findViewById(R.id.bMarkieren);        bNavigation = (Button) rootView.findViewById(R.id.bNavigation);        bWarning.setOnClickListener(this);        bMarker.setOnClickListener(this);        bNavigation.setOnClickListener(this);        init();        return rootView;    }    @Override    public void onLocationChanged(Location location) {    }    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR1)    @Override    public void onViewCreated(View view, Bundle savedInstanceState) {        super.onViewCreated(view, savedInstanceState);        MapFragment mapFragment = (MapFragment) getChildFragmentManager().findFragmentById(R.id.map);        mapFragment.getMapAsync(this);        // Location Daten laden        loadLocation(sharedPreferences.getString(file, null));    }    @Override    public void onMapReady(GoogleMap googleMap) {        mMap = googleMap;        mMap.setMapType(GoogleMap.MAP_TYPE_NORMAL);  //map typ        //Initialize Google Play Services        if (android.os.Build.VERSION.SDK_INT >= M) {            if (ContextCompat.checkSelfPermission(getActivity(),                    Manifest.permission.ACCESS_FINE_LOCATION)                    == PackageManager.PERMISSION_GRANTED) {                buildGoogleApiClient();                mMap.setMyLocationEnabled(true);            }        } else {            buildGoogleApiClient();            mMap.setMyLocationEnabled(true);        }    }    protected synchronized void buildGoogleApiClient() {        mGoogleApiClient = new GoogleApiClient.Builder(getActivity())                .addConnectionCallbacks(this)                .addOnConnectionFailedListener(this)                .addApi(LocationServices.API)                .build();        mGoogleApiClient.connect();    }    public static final int MY_PERMISSIONS_REQUEST_LOCATION = 99;    public boolean checkLocationPermission() {        if (ContextCompat.checkSelfPermission(getActivity(),                Manifest.permission.ACCESS_FINE_LOCATION)                != PackageManager.PERMISSION_GRANTED) {            // Asking user if explanation is needed            if (ActivityCompat.shouldShowRequestPermissionRationale(getActivity(),                    Manifest.permission.ACCESS_FINE_LOCATION)) {                // Show an explanation to the user *asynchronously* -- don't block                // this thread waiting for the user's response! After the user                // sees the explanation, try again to request the permission.                //Prompt the user once explanation has been shown                ActivityCompat.requestPermissions(getActivity(),                        new String[]{Manifest.permission.ACCESS_FINE_LOCATION},                        MY_PERMISSIONS_REQUEST_LOCATION);            } else {                // Keine Erklärung erforderlich.                ActivityCompat.requestPermissions(getActivity(),                        new String[]{Manifest.permission.ACCESS_FINE_LOCATION},                        MY_PERMISSIONS_REQUEST_LOCATION);            }            return false;        } else {            return true;        }    }    @Override    public void onConnected(Bundle bundle) {        mLocationRequest = new LocationRequest();        mLocationRequest.setInterval(10 * 1000);    // 10 seconds, in milliseconds        mLocationRequest.setFastestInterval(1000);  // 1 seconds, in milliseconds        mLocationRequest.setPriority(LocationRequest.PRIORITY_BALANCED_POWER_ACCURACY);        if (ContextCompat.checkSelfPermission(getActivity(),                Manifest.permission.ACCESS_FINE_LOCATION)                == PackageManager.PERMISSION_GRANTED) {            LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, mLocationRequest,                    this);        }    }    @Override    public void onConnectionSuspended(int i) {    }    @Override    public void onConnectionFailed(@NonNull ConnectionResult connectionResult) {    }    @Override    public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) {        switch (requestCode) {            case MY_PERMISSIONS_REQUEST_LOCATION: {                // If request is cancelled, the result arrays are empty.                if (grantResults.length > 0                        && grantResults[0] == PackageManager.PERMISSION_GRANTED) {                    // permission was granted. Do the                    // contacts-related task you need to do.                    if ((ContextCompat.checkSelfPermission(getActivity(),                            Manifest.permission.ACCESS_FINE_LOCATION)                            == PackageManager.PERMISSION_GRANTED) &&                            (ContextCompat.checkSelfPermission(getActivity(),                            Manifest.permission.ACCESS_COARSE_LOCATION)                            == PackageManager.PERMISSION_GRANTED)) {                        if (mGoogleApiClient == null) {                            buildGoogleApiClient();                        }                        mMap.setMyLocationEnabled(true);                    }                } else {                    // Permission denied, Deaktivieren Sie die Funktionalität,                    // die von der getActivity-Berechtigung abhängt.                    Toast.makeText(getActivity(), "Erlaubnis verweigert", Toast.LENGTH_LONG).show();                }                return;            }        }    }    @Override    public void onClick(View v) {        if (mLastLocation == null)            return; //ohne Location -> keine Warnung/Markierung möglich        if (v.getId() == bMarker.getId()) {            //Marker            mMap.moveCamera(CameraUpdateFactory.newLatLng(new LatLng(mLastLocation.getLatitude(),                    mLastLocation.getLongitude())));            if (bMarker.getText().toString().equals("Markieren")) {                markerLocation = mLastLocation;                bMarker.setText("Demarkieren");                saveLocation(getLocationString(mLastLocation));                bNavigation.setVisibility(View.VISIBLE);                //da Bewegung minimal -> minimale Abweichungen der Animation                // -> keine notwendige neue Animation                if (!zoomAnimationRunning)                    animatedZooming(markerLocation);            } else {                markerLocation = null;                bMarker.setText("Markieren");                bNavigation.setVisibility(View.GONE);                saveLocation(null);            }        } else if (v.getId() == bWarning.getId()) {            //Warning            showWarnDialog();        } else if(v.getId() == bNavigation.getId()) {            Intent navigationsIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(getMapsString()));            navigationsIntent.setClassName("com.google.android.apps.maps", "com.google.android.maps.MapsActivity");            startActivity(navigationsIntent);        }    }    /**     * Hilfsmethode um Maps link zu generieren     */    private String getMapsString() {        return ("http://maps.google.com/maps?saddr="+getLocationString(mLastLocation)                +"&daddr="+getLocationString(markerLocation));    }    /**         * Hilfsmethode zum Anzeigen eines Warndialogfensters zur Auswahl gegebener Optionen         */        private void showWarnDialog() {            final Dialog warnDialog = new Dialog(getActivity());            warnDialog.requestWindowFeature(Window.FEATURE_NO_TITLE);            warnDialog.setContentView(R.layout.warndialoglayout);            warnDialog.setCancelable(true);            //Aufrufen            warnDialog.findViewById(R.id.warndialoglayout_abbrechen)                    .setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View view) {                    warnDialog.cancel();                }            });            warnDialog.findViewById(R.id.warndialoglayuot_senden)                    .setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View view) {                    // senden warnung                    // nutze hilfsmethode unter dieser methode für location string                }            });            warnDialog.show();        }    /**     * Hilfsmethode zum Speichern der Location (OFFLINE/LOCAL)     */    private void saveLocation(String input) {        SharedPreferences.Editor edit = sharedPreferences.edit();        edit.putString(file, input);        if(!edit.commit())            Toast.makeText(getActivity(), "Speichern der Location fehlgeschlagen!", Toast.LENGTH_LONG).show();    }    /**     * Hilfsmethode zum Laden der Location (OFFLINE)     */    private void loadLocation(String input) {        if(input == null)            return;        String[] lstring = input.split(",");        markerLocation = new Location((String) null);        try {            markerLocation.setLatitude(Double.parseDouble(lstring[0]));            markerLocation.setLongitude(Double.parseDouble(lstring[1]));        } catch(Exception e) {            Toast.makeText(getActivity(), "Fehler beim Laden der lokalen Daten aufgetreten!", Toast.LENGTH_LONG).show();            return;        }        bMarker.setText("Demarkieren");        bNavigation.setVisibility(View.VISIBLE);    }    /**     * Hilfsmethode um die Location als String zurückzugeben     * zur Nutzung der Werte :     * split("/")[0] = latitude     * split("/")[1] = longitude     */    private String getLocationString(Location location) {        return (String.valueOf(location.getLatitude()) + "," +                String.valueOf(location.getLongitude()));    }}